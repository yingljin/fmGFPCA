---
title: "Simulation"
author: "Ying Jin"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    toc_depth: 3
    self_contained: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(knitr.kable.NA = '')

set.seed(625)

library(tidyverse)
library(here)
library(kableExtra)
library(ggpubr)
theme_set(theme_minimal())

# color
library(RColorBrewer)

load(here("Data/SimOutput/SimOutput_J200.RData"))
load(here("Data/SimOutput/SimOutput_J200_ref.RData"))


# valid_id <- which(pred_time_vec<=10)

```


# Simulation: dynamic prediction

## Simulation set-up

This file documents the simulation scheme of multi-level functional data. 

- Sample size: training = 100, test = 100
- Number of visits J = 3
- Number of observations at each vitis K = 200 (when K = 100, numeric issues are likely to happen)
- Make prediction with observations until the middle of visit 2 and 3 separately
- 100 simulations



- Binary outcomes: 

$$Y_{ij}(t) \sim Bernoulli(g(\eta_{ij}(t)))$$

$$\eta_{ij}(t)=b_0(t)+\sum_{l=1}^4\xi_{il}\phi_l(t)+\sum_{m=1}^4\zeta_{ijm}\psi_m(t)$$


- Level 1: 

$$\phi_l(t) = \{\sqrt{2}sin(2\pi t), \sqrt2 cos(2\pi t), \sqrt2 sin (4\pi t), \sqrt2 cos(4\pi t)\}$$

$$\xi_{il} \sim N(0, \lambda_l), \hspace{0.5cm} \lambda_l = 0.5^{l-1}, l=1,2, 3, 4$$

## Results

### Figure

```{r color_setting}
cols <- c(brewer.pal(3, "Set2"), "#000000") # define a color palette 
names(cols) <- c("0 full visits", "1 full visit", "2 full visits", "True")
```

```{r pred_sim, fig.width=14}
p1 <- pred_list_allM[[1]] %>%
  filter(id %in% 101:104) %>%
  mutate(eta_pred_J1 = ifelse(t<=0.5, NA, eta_pred_J1),
         eta_pred_J2 = ifelse(visit==1|(visit %in% 2:3 & t<=0.5), NA, eta_pred_J2),
         eta_pred_J3 = ifelse(visit %in% 1:2|(visit==3&t<=0.5), NA, eta_pred_J3)) %>%
  mutate_at(vars(starts_with("eta_pred")), function(x)(exp(x)/(1+exp(x)))) %>% 
  ggplot()+
  geom_line(aes(x=t, y=probs, col="True"), linewidth=0.5)+
  geom_line(aes(x=t, y=eta_pred_J1, col = "0 full visits"), 
            linetype="dashed", 
            na.rm = T)+
  geom_line(aes(x=t, y=eta_pred_J2, col = "1 full visit"), 
            linetype="dashed", 
            na.rm = T)+
  geom_line(aes(x=t, y=eta_pred_J3, col = "2 full visits"), 
            linetype="dashed", 
            na.rm = T)+
  geom_point(aes(x=t, y=Y,  col="True"), size = 0.2)+
  facet_grid(row = vars(id), col=vars(visit))+
  scale_color_manual(values = cols)+
  labs(title = "gmFPCA", color = "", y="", x="t")


p2 <- pred_list_allM_ref[[1]] %>%
  filter(id %in% 101:104) %>%
  mutate(eta_pred_J1 = ifelse(t<=0.5, NA, eta_pred_J1),
         eta_pred_J2 = ifelse(visit==1|(visit %in% 2:3 & t<=0.5), NA, eta_pred_J2),
         eta_pred_J3 = ifelse(visit %in% 1:2|(visit==3&t<=0.5), NA, eta_pred_J3)) %>%
  mutate_at(vars(starts_with("eta")), function(x)(exp(x)/(1+exp(x)))) %>% 
  ggplot()+
  geom_line(aes(x=t, y=eta, col="True"), linewidth=0.5)+
  geom_line(aes(x=t, y=eta_pred_J1, col = "0 full visits"), 
            linetype="dashed", na.rm = T, alpha = 0.5, linewidth = 1)+
  geom_line(aes(x=t, y=eta_pred_J2, col = "1 full visit"), 
            linetype="dashed",na.rm = T, alpha = 0.5, linewidth = 0.8)+
  geom_line(aes(x=t, y=eta_pred_J3, col = "2 full visits"), 
            linetype="dashed", na.rm = T, alpha = 0.5, linewidth = 0.6)+
  geom_point(aes(x=t, y=Y, col = "True"), size = 0.2)+
  facet_grid(row = vars(id), col=vars(visit))+
  scale_color_manual(values=cols)+
  labs(title = "GLMMadaptive", col="", y="", x="t")

ggarrange(p1, p2, common.legend = T)
# ggsave(filename = here("Images/sim_pred.png"), 
#        width=10, height = 4, bg = "white")
```

### Computation time

```{r}
# print("Computation time:")
data.frame("gmFPCA" = c(mean(fit_time_vec), 
                        mean(pred_time_vec)),
           "GLMMadaptive" = c(mean(fit_time_vec_ref),
                              mean(pred_time_vec_ref))) %>% 
  mutate("Time (mins)" = c("Fit", "Prediction"), .before=1) %>%
  kable(digits = 2) %>% 
  kable_styling(full_width = F)



```


### Integerated squared error

- Over the entire prediction window

```{r, message=FALSE}
ise_gmfpca <- bind_rows(pred_list_allM, .id = "iter") %>% 
  mutate(window = cut(t, breaks = c(0, 0.5, 1), include.lowest = T)) %>%
  mutate(error_J1 = (eta_pred_J1-eta)^2,
         error_J2 = (eta_pred_J2-eta)^2,
         error_J3 = (eta_pred_J3-eta)^2) %>%
  group_by(iter, visit, window, id) %>%
  summarise_at(vars(starts_with("error_")), sum) %>% 
  group_by(iter, visit, window) %>%
  summarise_at(vars(starts_with("error_")), mean) %>% 
  group_by(visit, window) %>%
  summarise_at(vars(starts_with("error_")), mean)

ise_gmfpca <- ise_gmfpca %>% filter(window == "(0.5,1]")
ise_gmfpca$error_J2[1] <- NA
ise_gmfpca$error_J3[1:2] <- NA
colnames(ise_gmfpca) <- c("Visit", "Time",
                          "All half visits", "Full visit 1, half visit 2 and 3",
                          "Full visit 1 and 2, half visit 3")
```


```{r}
ise_glmmad <- bind_rows(pred_list_allM_ref, .id = "iter") %>% 
  mutate(window = cut(t, breaks = c(0, 0.5, 1), include.lowest = T)) %>%
  mutate(error_J1 = (eta_pred_J1-eta)^2,
         error_J2 = (eta_pred_J2-eta)^2,
         error_J3 = (eta_pred_J3-eta)^2) %>%
  group_by(iter, visit, window, id) %>%
  summarise_at(vars(starts_with("error_")), sum) %>% 
  group_by(iter, visit, window) %>%
  summarise_at(vars(starts_with("error_")), mean) %>% 
  group_by(visit, window) %>%
  summarise_at(vars(starts_with("error_")), mean)  

ise_glmmad <- ise_glmmad %>% filter(window == "(0.5,1]")
ise_glmmad$error_J2[1] <- NA
ise_glmmad$error_J3[1:2] <- NA
colnames(ise_glmmad) <- c("Visit", "Time",
                          "All half visits", "Full visit 1, half visit 2 and 3",
                          "Full visit 1 and 2, half visit 3")
```

```{r}
# print("Integrated squared error:")
ise_gmfpca %>% 
  add_column(ise_glmmad[,3:5], .name_repair = "minimal") %>%
  kable(digits = 2) %>% 
  kable_styling(full_width = F) %>%
  add_header_above(c("Prediction window" = 2,
                         "Observed window" = 6))
```

For visit 3, the predictions are identical. This is not a coding error. Because prediction of the three visits are made at the same time, and the other visits are not identical. 

For GLMM adaptive, it doesn't matter how much data is observed before the prediction window. The prediction stays identical. 


# Simulation: compute missing values

- No need to data splitting. This can be done in all in-sample context.
I can just use the score from mfpca.face model to compute missing value. 
- 100 subjects in total. 10% percent subject, each with 50% missing. 
- For GLMM adaptive, I was able to fit a linear model with id_visit grouping (not nested). The *predict.MixMod* function couldn't make subject-visit specific prediction. I had to extract random coefficients and calculate the prediction by hand. 
- Also, GLMM adaptive failed one dataset (43th) due to numeric problem. 

```{r load_mis_output}
load(here("Data/SimOutput/SimOutput_miss.RData"))
load(here("Data/SimOutput/SimOutput_miss_ref.RData"))
```

## Figure

```{r color_setting2}
cols <- c("#66C2A5", "#000000") # define a color palette 
names(cols) <- c("Computed", "Observed/True")
```

```{r miss_sim, fig.width=14}
# unique(comp_list_allM_ref[[1]]$id)
p1 <- comp_list_allM[[1]] %>%
  filter(id %in% c(30, 32, 37, 38)) %>% 
  mutate_at(vars(starts_with("eta")), 
            function(x)(exp(x)/(1+exp(x)))) %>%
  mutate(eta=ifelse(is.na(Yobs), NA, eta),
         eta_comp=ifelse(is.na(Yobs), eta_comp, NA)) %>% 
  ggplot()+
  geom_point(aes(x=t, y=eta, col="Observed/True"), size = 0.1, na.rm = T)+
  geom_point(aes(x=t, y=eta_comp, col="Computed"), size = 0.1, 
             na.rm = T)+
  geom_point(aes(x=t, y=Yobs, col = "Observed/True"), size = 0.1,
             na.rm = T)+
  facet_grid(rows = vars(id), cols = vars(visit))+
  scale_color_manual(values = cols)+
  labs(title = "gmFPCA", colour="", y="", x="t")

p2 <- comp_list_allM_ref[[1]] %>%
  filter(id %in% c(30, 32, 37, 38)) %>% 
  mutate_at(vars(starts_with("eta")), 
            function(x)(exp(x)/(1+exp(x)))) %>%
  mutate(eta=ifelse(is.na(Yobs), NA, eta),
         eta_comp=ifelse(is.na(Yobs), eta_comp, NA)) %>% 
  ggplot()+
  geom_point(aes(x=t, y=eta, col="Observed/True"), size = 0.1, na.rm = T)+
  geom_point(aes(x=t, y=eta_comp, col="Computed"), size = 0.1, 
             na.rm = T)+
  geom_point(aes(x=t, y=Yobs, col="Observed/True"), size = 0.1,
             na.rm = T)+
  facet_grid(rows = vars(id), cols = vars(visit))+
  scale_color_manual(values=cols)+
  labs(title = "GLMMadaptive", colour="", y="", x="t")

ggarrange(p1, p2, common.legend = T)
```

## Computation time

```{r}
# print("Computation time:")
data.frame("gmFPCA" = mean(comp_time_vec),
           "GLMMadaptive" = mean(comp_time_vec_ref, na.rm=T)) %>% 
  mutate(" " = "Time (minutes)", .before=1) %>%
  kable(digits = 2) %>% 
  kable_styling(full_width = F)
```


## Integrated squared error

- Average acros all single values

```{r, message=FALSE}
ise_gmfpca2 <- bind_rows(comp_list_allM, .id = "iter") %>% 
  filter(is.na(Yobs)) %>%
  mutate(error = (eta_comp-eta)^2) %>%
  summarise(error = mean(error))

ise_glmmad2 <- bind_rows(comp_list_allM_ref, .id = "iter") %>% 
  filter(is.na(Yobs)) %>%
  mutate(error = (eta_comp-eta)^2) %>%
  summarise(error = mean(error))
```

```{r}
# print("Integrated squared error:")
data.frame("gmFPCA" = ise_gmfpca2[1, 1], 
           "GLMMadaptive"= ise_glmmad2[1, 1]) %>%
  kable(digits = 2) %>% 
  kable_styling(full_width = F)
```

In fact the missing data scenario appears a better illustration. 
