---
title: "Simulation"
author: "Ying Jin"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    toc_depth: 3
    self_contained: false
  pdf_document:
    toc: true
    toc_depth: '3'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(knitr.kable.NA = '')

set.seed(625)

library(tidyverse)
library(here)
library(kableExtra)
library(ggpubr)
theme_set(theme_minimal())
library(ROCR)

# color
library(RColorBrewer)
# display.brewer.pal(5, "Set2")
# myPalette <- c("#000000", brewer.pal(5, "Set2"))

# simulated data 
load(here("Data/SimData/SimData.RData"))

# simulation output
load(here("Data/SimOutput/SimOutputMulti.RData"))
time_gmFPCA <- fit_time_vec+pred_time_vec

load(here("Data/SimOutput/SimOutputSingle.RData"))


```


# Simulation: dynamic prediction

## Simulation set-up

This file documents the simulation scheme of multi-level functional data. 

- Sample size: training = 100, test = 100
- Number of series J = 2 (reduced because of computation time)
- Number of observations at each vitis K = 200 (when K = 100, numeric issues are likely to happen)
- Make prediction with observations until the middle of series 2 and 3 separately
- 100 simulations



- Binary outcomes: 

$$Y_{ij}(t) \sim Bernoulli(g(\eta_{ij}(t)))$$

$$\eta_{ij}(t)=b_0(t)+\sum_{l=1}^4\xi_{il}\phi_l(t)+\sum_{m=1}^4\zeta_{ijm}\psi_m(t)$$




$$
\begin{aligned}
\text{Subject level: } & \mathbf{\Phi} = \{\sqrt{2}sin(2\pi t), \sqrt2 cos(2\pi t), \sqrt2 sin (4\pi t), \sqrt2 cos(4\pi t)\}, \\
                       & \mathbf{\Lambda}  = \{0.5^{l-1}\}, l=1,2, 3, 4;\\
\text{Subject-series level: } & \mathbf{\Psi} = \{\sqrt{2}sin(6\pi t), \sqrt2 cos(6\pi t), \sqrt2 sin (8\pi t), \sqrt2 cos(8\pi t)\},\\
                             & \mathbf{\Gamma} = \{0.5^{m-1}\}, m=1,2, 3, 4.
\end{aligned}
$$


Below is an example of generated data 

```{r}
data_list[[1]] %>% 
  filter(id %in% 101:104) %>%
  ggplot()+
  geom_point(aes(x=t, y= Y, col = "Outcome"), size = 0.2)+
  geom_line(aes(x=t, y=probs, col = "Latent"))+
  facet_grid(rows = vars(id), cols = vars(visit))+
  scale_color_manual(values = c("Outcome" = "#000000",
                                "Latent" = "#66C2A5"))

```

## Results

Here, I have changed the competing method to single-level fGFPCA, because the GLMMadaptice is clearly not fitting the correct model. 

### Predicted tracks

Take subject 101-104 in the test set as example: 

```{r color_setting}
cols <- c("#FC8D62", "#8DA0CB", "#000000") # define a color palette
names(cols) <- c("Half series", "One and a half series", "True")
```

```{r}
p1 <- pred_list_allM[[1]] %>%
  filter(id %in% 101:104) %>%
  rename(series = visit) %>%
  mutate(eta_pred_J1 = ifelse(series==1 & t<=0.5, NA, eta_pred_J1),
         eta_pred_J2 = ifelse(series==2 & t > 0.5, eta_pred_J2, NA)) %>%
  mutate_at(vars(starts_with("eta_pred")), function(x)(exp(x)/(1+exp(x)))) %>%
  ggplot()+
  geom_line(aes(x=t, y=probs, col="True"), linewidth=0.5, linetype = "dashed")+
  geom_line(aes(x=t, y=eta_pred_J1, col = "Half series"),
            linewidth = 1,
            na.rm = T)+
  geom_line(aes(x=t, y=eta_pred_J2, col = "One and a half series"),
            linewidth = 1,
            na.rm = T)+ 
  geom_point(aes(x=t, y=Y,  col="True"), size = 0.2)+
  facet_grid(row = vars(id), col=vars(series))+
  scale_color_manual(values = cols)+
  labs(title = "gmFPCA", color = "", y="", x="t")
```

```{r}
p2 <- pred_list_fGFPCA[[1]] %>%
  filter(id %in% 101:104) %>%
  rename(series = visit,
         eta_pred_J1 = pred50, eta_pred_J2 = pred150) %>%
  mutate(eta_pred_J1 = ifelse(series==1 & t<=0.5, NA, eta_pred_J1),
         eta_pred_J2 = ifelse(series==2 & t > 0.5, eta_pred_J2, NA)) %>%
  mutate_at(vars(starts_with("eta_pred")), function(x)(exp(x)/(1+exp(x)))) %>%
  ggplot()+
  geom_line(aes(x=t, y=probs, col="True"), linewidth=0.5, linetype = "dashed")+
  geom_line(aes(x=t, y=eta_pred_J1, col = "Half series"),
            linewidth = 1,
            na.rm = T)+
  geom_line(aes(x=t, y=eta_pred_J2, col = "One and a half series"),
            linewidth = 1,
            na.rm = T)+ 
  geom_point(aes(x=t, y=Y,  col="True"), size = 0.2)+
  facet_grid(row = vars(id), col=vars(series))+
  scale_color_manual(values = cols)+
  labs(title = "fGFPCA", color = "", y="", x="t")
```


```{r, fig.width=10}
ggarrange(p1, p2, nrow = 1, common.legend = T)
```

### Computation time

```{r}
# print("Computation time:")
data.frame("gmFPCA" = c(mean(time_gmFPCA)),
           "fGFPCA" = c(mean(time_fGFPCA))) %>%
  mutate("Time (mins)" = NA, .before=1) %>%
  kable(digits = 2) %>%
  kable_styling(full_width = F)
```

### Integerated squared error

```{r}
ise_gmFPCA <- bind_rows(pred_list_allM, .id = "iter") %>%
  mutate(window = cut(t, breaks = c(0, 0.5, 1), include.lowest = T)) %>%
  mutate(error_J1 = (eta_pred_J1-eta)^2,
         error_J2 = (eta_pred_J2-eta)^2) %>%
  group_by(iter, visit, window, id) %>%
  summarise_at(vars(starts_with("error_")), sum) %>%
  group_by(iter, visit, window) %>%
  summarise_at(vars(starts_with("error_")), mean) %>%
  group_by(visit, window) %>%
  summarise_at(vars(starts_with("error_")), mean)

ise_gmFPCA$error_J1[1] <- NA
ise_gmFPCA$error_J2[1:3] <- NA
```

```{r, message=FALSE}
ise_fGFPCA <- bind_rows(pred_list_fGFPCA, .id = "iter") %>%
  mutate(window = cut(t, breaks = c(0, 0.5, 1), include.lowest = T)) %>%
  mutate(error_J1 = (pred50-eta)^2,
         error_J2 = (pred150-eta)^2) %>%
  group_by(iter, visit, window, id) %>%
  summarise_at(vars(starts_with("error_")), sum) %>%
  group_by(iter, visit, window) %>%
  summarise_at(vars(starts_with("error_")), mean) %>%
  group_by(visit, window) %>%
  summarise_at(vars(starts_with("error_")), mean)

ise_fGFPCA$error_J1[1] <- NA
ise_fGFPCA$error_J2[1:3] <- NA
```

```{r}
ise <- inner_join(ise_gmFPCA, ise_fGFPCA, by = c("visit", "window"))

colnames(ise) <- c("Series", "Prediction window",
                          "Half series", "One and a half series",
                          "Half series", "One and a half series")

ise %>% kable(digits = 2) %>% 
  kable_styling(full_width = F) %>%
  add_header_above(c(" " = 2, "gmFPCA" = 2, "fGFPCA" = 2)) 
```


### AUC

```{r, message=FALSE}
auc_gmFPCA <- bind_rows(pred_list_allM, .id = "iter") %>%
  mutate(window = cut(t, breaks = c(0, 0.5, 1), include.lowest = T)) %>%
  group_by(iter, id, visit, window) %>%
  summarize(auc_J1 = performance(prediction(eta_pred_J1, Y),
                               measure = "auc")@y.values[[1]],
            auc_J2 = performance(prediction(eta_pred_J2, Y),
                               measure = "auc")@y.values[[1]]) %>%
  group_by(visit, window) %>%
  summarise_at(vars(starts_with("auc_")), mean)

auc_gmFPCA$auc_J1[1] <- NA
auc_gmFPCA$auc_J2[1:3] <- NA
```

```{r, message=FALSE}
auc_fGFPCA <- bind_rows(pred_list_fGFPCA, .id = "iter") %>%
  mutate(window = cut(t, breaks = c(0, 0.5, 1), include.lowest = T)) %>%
  group_by(iter, id, visit, window) %>%
  summarize(auc_J1 = performance(prediction(pred50, Y),
                               measure = "auc")@y.values[[1]],
            auc_J2 = performance(prediction(pred150, Y),
                               measure = "auc")@y.values[[1]]) %>%
  group_by(visit, window) %>%
  summarise_at(vars(starts_with("auc_")), mean)

auc_fGFPCA$auc_J1[1] <- NA
auc_fGFPCA$auc_J2[1:3] <- NA
```

```{r}
auc <- inner_join(auc_gmFPCA, auc_fGFPCA, by = c("visit", "window"))

colnames(auc) <- c("Series", "Prediction window",
                          "Half series", "One and a half series",
                          "Half series", "One and a half series")

auc %>% kable(digits = 2) %>% 
  kable_styling(full_width = F) %>%
  add_header_above(c(" " = 2, "gmFPCA" = 2, "fGFPCA" = 2)) 

```

# Some thoughts

- I think single-level fGFPCA is clearly a better option of reference method, because GLMMadaptive is clearly not fitting the right model, and other methods clearly cannot do out-of-sample prediction without model refitting.

- If we really need to incorporate GLMM, I think it might be better to compare in-sample prediction. In that case at least we know the model has the "correct" grouping structure.

- For the second case (missing value), what we would be doing is essentially point2


<!-- # Simulation: compute missing values -->

<!-- - No need to data splitting. This can be done in all in-sample context. -->
<!-- I can just use the score from mfpca.face model to compute missing value. -->
<!-- - 100 subjects in total. 10% percent subject, each with 50% missing. -->
<!-- - For GLMM adaptive, I was able to fit a linear model with id_visit grouping (not nested). The *predict.MixMod* function couldn't make subject-series specific prediction. I had to extract random coefficients and calculate the prediction by hand. -->
<!-- - Also, GLMM adaptive failed one dataset (43th) due to numeric problem. -->

<!-- ```{r load_mis_output} -->
<!-- load(here("Data/SimOutput/SimOutput_miss.RData")) -->
<!-- load(here("Data/SimOutput/SimOutput_miss_ref.RData")) -->
<!-- ``` -->

<!-- ## Figure -->

<!-- ```{r color_setting2} -->
<!-- cols <- c("#66C2A5", "#000000") # define a color palette  -->
<!-- names(cols) <- c("Computed", "Observed/True") -->
<!-- ``` -->

<!-- ```{r miss_sim, fig.width=12, fig.height=4} -->
<!-- rand_id <- sample(unique(comp_list_allM_ref[[1]]$id), 2) -->

<!-- p1 <- comp_list_allM[[1]] %>% -->
<!--   filter(id %in% rand_id) %>% -->
<!--   rename(series = visit) %>% -->
<!--   mutate_at(vars(starts_with("eta")),  -->
<!--             function(x)(exp(x)/(1+exp(x)))) %>% -->
<!--   mutate(eta=ifelse(is.na(Yobs), NA, eta), -->
<!--          eta_comp=ifelse(is.na(Yobs), eta_comp, NA)) %>%  -->
<!--   ggplot()+ -->
<!--   geom_point(aes(x=t, y=eta, col="Observed/True"), size = 0.1, na.rm = T)+ -->
<!--   geom_point(aes(x=t, y=eta_comp, col="Computed"), size = 0.1,  -->
<!--              na.rm = T)+ -->
<!--   geom_point(aes(x=t, y=Yobs, col = "Observed/True"), size = 0.1, -->
<!--              na.rm = T)+ -->
<!--   facet_grid(rows = vars(id), cols = vars(series))+ -->
<!--   scale_color_manual(values = cols)+ -->
<!--   labs(title = "gmFPCA", colour="", y="", x="t") -->

<!-- p2 <- comp_list_allM_ref[[1]] %>% -->
<!--   filter(id %in% rand_id) %>%  -->
<!--   rename(series = visit) %>% -->
<!--   mutate_at(vars(starts_with("eta")),  -->
<!--             function(x)(exp(x)/(1+exp(x)))) %>% -->
<!--   mutate(eta=ifelse(is.na(Yobs), NA, eta), -->
<!--          eta_comp=ifelse(is.na(Yobs), eta_comp, NA)) %>%  -->
<!--   ggplot()+ -->
<!--   geom_point(aes(x=t, y=eta, col="Observed/True"), size = 0.1, na.rm = T)+ -->
<!--   geom_point(aes(x=t, y=eta_comp, col="Computed"), size = 0.1,  -->
<!--              na.rm = T)+ -->
<!--   geom_point(aes(x=t, y=Yobs, col="Observed/True"), size = 0.1, -->
<!--              na.rm = T)+ -->
<!--   facet_grid(rows = vars(id), cols = vars(series))+ -->
<!--   scale_color_manual(values=cols)+ -->
<!--   labs(title = "GLMMadaptive", colour="", y="", x="t") -->

<!-- ggarrange(p1, p2, nrow = 1, common.legend = T, legend = "bottom") -->
<!-- ``` -->

<!-- ## Computation time -->

<!-- ```{r} -->
<!-- # print("Computation time:") -->
<!-- data.frame("gmFPCA" = mean(comp_time_vec), -->
<!--            "GLMMadaptive" = mean(comp_time_vec_ref, na.rm=T)) %>%  -->
<!--   mutate(" " = "Time (minutes)", .before=1) %>% -->
<!--   kable(digits = 2) %>%  -->
<!--   kable_styling(full_width = F) -->
<!-- ``` -->


<!-- ## Integrated squared error -->

<!-- - Average acros all single values -->

<!-- ```{r, message=FALSE} -->
<!-- ise_gmfpca2 <- bind_rows(comp_list_allM, .id = "iter") %>%  -->
<!--   filter(is.na(Yobs)) %>% -->
<!--   mutate(error = (eta_comp-eta)^2) %>% -->
<!--   group_by(iter, id) %>%  -->
<!--   summarize(error = sum(error)) %>% -->
<!--   ungroup() %>% -->
<!--   summarise(error = mean(error)) -->

<!-- ise_glmmad2 <- bind_rows(comp_list_allM_ref, .id = "iter") %>%  -->
<!--   filter(is.na(Yobs)) %>% -->
<!--   mutate(error = (eta_comp-eta)^2) %>% -->
<!--   group_by(iter, id) %>%  -->
<!--   summarize(error = sum(error)) %>% -->
<!--   ungroup() %>% -->
<!--   summarise(error = mean(error)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # print("Integrated squared error:") -->
<!-- data.frame("gmFPCA" = ise_gmfpca2[1, 1],  -->
<!--            "GLMMadaptive"= ise_glmmad2[1, 1]) %>% -->
<!--   kable(digits = 2) %>%  -->
<!--   kable_styling(full_width = F) -->
<!-- ``` -->

<!-- In fact the missing data scenario appears a better illustration.  -->

<!-- ## AUC -->

<!-- ```{r, message=FALSE} -->
<!-- auc_gmfpca2 <- bind_rows(comp_list_allM, .id = "iter") %>%  -->
<!--   filter(is.na(Yobs)) %>% -->
<!--   group_by(iter, id) %>%  -->
<!--   summarise(auc = performance(prediction(eta_comp, Y), -->
<!--                               measure = "auc")@y.values[[1]]) %>% -->
<!--   ungroup() %>% -->
<!--   summarise(auc = mean(auc)) -->

<!-- auc_glmmad2 <- bind_rows(comp_list_allM_ref, .id = "iter") %>%  -->
<!--   filter(is.na(Yobs)) %>% -->
<!--   group_by(iter, id) %>%  -->
<!--   summarise(auc = performance(prediction(eta_comp, Y), -->
<!--                               measure = "auc")@y.values[[1]]) %>% -->
<!--   ungroup() %>% -->
<!--   summarise(auc = mean(auc)) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- data.frame("gmFPCA" = auc_gmfpca2[1, 1],  -->
<!--            "GLMMadaptive"= auc_glmmad2[1, 1]) %>% -->
<!--   kable(digits = 2) %>%  -->
<!--   kable_styling(full_width = F) -->
<!-- ``` -->